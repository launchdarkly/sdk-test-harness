---
name: rule match (<TYPE_NAME>)

constants:
  CONTEXT: { key: "user-key" }
  IS_MATCH_RULE1:
    value: <TYPE_VALUE_1>
    variationIndex: 2
    reason: { "kind": "RULE_MATCH", "ruleIndex": 0, "ruleId": "rule1" }
  IS_MATCH_RULE2:
    value: <TYPE_VALUE_2>
    variationIndex: 3
    reason: { "kind": "RULE_MATCH", "ruleIndex": 1, "ruleId": "rule2" }
  IS_FALLTHROUGH:
    value: <TYPE_VALUE_FALLTHROUGH>
    variationIndex: 1
    reason: { "kind": "FALLTHROUGH" }
  EXPECTED_ERROR_RESULT:
    value: "<TYPE_DEFAULT>"
    reason: { "kind": "ERROR", "errorKind": "MALFORMED_FLAG" }

parameters:
  - TYPE_NAME: bool
    TYPE_VALUE_OFF: false
    TYPE_VALUE_FALLTHROUGH: false
    TYPE_VALUE_1: true
    TYPE_VALUE_2: false
    TYPE_DEFAULT: false

  - TYPE_NAME: int
    TYPE_VALUE_OFF: -100
    TYPE_VALUE_FALLTHROUGH: -101
    TYPE_VALUE_1: 1
    TYPE_VALUE_2: 2
    TYPE_DEFAULT: -1

  - TYPE_NAME: double
    TYPE_VALUE_OFF: -100
    TYPE_VALUE_FALLTHROUGH: -101
    TYPE_VALUE_1: 1.5
    TYPE_VALUE_2: 2.5
    TYPE_DEFAULT: 0.5

  - TYPE_NAME: string
    TYPE_VALUE_OFF: "off"
    TYPE_VALUE_FALLTHROUGH: "fall"
    TYPE_VALUE_1: "a"
    TYPE_VALUE_2: "b"
    TYPE_DEFAULT: "default"

  - TYPE_NAME: any
    TYPE_VALUE_OFF: "off"
    TYPE_VALUE_FALLTHROUGH: "fall"
    TYPE_VALUE_1: 3
    TYPE_VALUE_2: "b"
    TYPE_DEFAULT: false

sdkData:
  flags:
    flag-with-rules:
      on: true
      variations: [ <TYPE_VALUE_OFF>, <TYPE_VALUE_FALLTHROUGH>, <TYPE_VALUE_1>, <TYPE_VALUE_2> ]
      offVariation: 0
      fallthrough: { variation: 1 }
      rules:
        - id: rule1
          variation: 2
          clauses:
            - { "attribute": "rule1Clause1ShouldMatch", "op": "in", "values": [ true ] }
            - { "attribute": "rule1Clause2ShouldMatch", "op": "in", "values": [ true ] }
        - id: rule2
          variation: 3
          clauses:
            - { "attribute": "rule2ShouldMatch", "op": "in", "values": [ true ] }

    off-flag-with-rule:
      on: false
      variations: [ <TYPE_VALUE_OFF>, <TYPE_VALUE_FALLTHROUGH>, <TYPE_VALUE_1>, <TYPE_VALUE_2> ]
      offVariation: 0
      fallthrough: { variation: 1 }
      rules:
        - id: rule1
          variation: 2
          clauses:
            - { "attribute": "rule1ShouldMatch", "op": "in", "values": [ true ] }

    flag-with-unknown-operator-in-first-rule:
      on: true
      variations: [ <TYPE_VALUE_OFF>, <TYPE_VALUE_FALLTHROUGH>, <TYPE_VALUE_1>, <TYPE_VALUE_2> ]
      offVariation: 0
      fallthrough: { variation: 1 }
      rules:
        - id: rule1
          variation: 2
          clauses:
            - { "attribute": "key", "op": "unsupportedOperator", "values": [ true ] }
        - id: rule2
          variation: 3
          clauses:
            - { "attribute": "rule2ShouldMatch", "op": "in", "values": [ true ] }

    flag-with-negated-clause:
      on: true
      variations: [ <TYPE_VALUE_OFF>, <TYPE_VALUE_FALLTHROUGH>, <TYPE_VALUE_1>, <TYPE_VALUE_2> ]
      offVariation: 0
      fallthrough: { variation: 1 }
      rules:
        - id: rule1
          variation: 2
          clauses:
            - { "attribute": "attrname", "op": "in", "values": [ "undesirable-key" ], negate: true }

evaluations:
  - name: all clauses of rule1 match
    flagKey: flag-with-rules
    context:
      key: user-key
      custom:
        rule1Clause1ShouldMatch: true
        rule1Clause2ShouldMatch: true
    valueType: <TYPE_NAME>
    default: <TYPE_DEFAULT>
    expect: <IS_MATCH_RULE1>

  - name: rule2 matches, after one clause of rule1 fails
    flagKey: flag-with-rules
    context:
      key: user-key
      custom:
        rule1Clause1ShouldMatch: true
        rule1Clause2ShouldMatch: false
        rule2ShouldMatch: true
    valueType: <TYPE_NAME>
    default: <TYPE_DEFAULT>
    expect: <IS_MATCH_RULE2>

  - name: unknown operator is treated as a non-match, can still match another rule
    flagKey: flag-with-unknown-operator-in-first-rule
    context:
      key: user-key
      custom:
        rule2ShouldMatch: true
    valueType: <TYPE_NAME>
    default: <TYPE_DEFAULT>
    expect: <IS_MATCH_RULE2>

  - name: no rules match, fallthrough
    flagKey: flag-with-rules
    context: { "key": "user-key" }
    valueType: <TYPE_NAME>
    default: <TYPE_DEFAULT>
    expect:
      value: <TYPE_VALUE_FALLTHROUGH>
      variationIndex: 1
      reason: { "kind": "FALLTHROUGH" }

  - name: rules are ignored when flag is off
    flagKey: off-flag-with-rule
    context:
      key: user-key
      custom:
        rule1ShouldMatch: true
    valueType: <TYPE_NAME>
    default: <TYPE_DEFAULT>
    expect:
      value: <TYPE_VALUE_OFF>
      variationIndex: 0
      reason: { "kind": "OFF" }

  - name: negated clause, non-match becomes match
    flagKey: flag-with-negated-clause
    context:
      key: user-key
      custom:
        attrname: undesirable-key
    valueType: <TYPE_NAME>
    default: <TYPE_DEFAULT>
    expect: <IS_FALLTHROUGH>

  - name: negated clause, match becomes non-match
    flagKey: flag-with-negated-clause
    context:
      key: user-key
      custom:
        attrname: any-other-value
    valueType: <TYPE_NAME>
    default: <TYPE_DEFAULT>
    expect: <IS_MATCH_RULE1>

  - name: negated clause, null user attribute is always non-match regardless of negation
    flagKey: flag-with-negated-clause
    context:
      key: user-key
      custom:
        attrname: null
    valueType: <TYPE_NAME>
    default: <TYPE_DEFAULT>
    expect: <IS_FALLTHROUGH>
